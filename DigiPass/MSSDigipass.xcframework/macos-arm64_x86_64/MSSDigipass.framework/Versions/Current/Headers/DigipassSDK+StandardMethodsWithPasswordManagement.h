//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) since 1999. VASCO DATA SECURITY
//  All rights reserved. http://www.vasco.com
//
//////////////////////////////////////////////////////////////////////////////

#import <MSSDigipass/DigipassSDK.h>

NS_ASSUME_NONNULL_BEGIN

@class DigipassSDKGenericResponse;
@class DigipassSDKSignatureResponse;
@class DigipassSDKActivationResponse;
@class DigipassSDKGenerationResponse;

/**
 * This category of DIgipass SDK describes the Standard Activation methods with a Password Management.
 */
@interface DigipassSDK (StandardMethodsWithPasswordManagement)

/**
 * Offline activation / reactivation process.
 * <ul>
 *  <li>Parses the DIGIPASS settings.</li>
 *  <li>Checks and formats the activation data.</li>
 *  <li>Extracts DIGIPASS secrets from the activation data and encrypts them by using a key derived from the password.</li>
 *  <li>Updates a DIGIPASS counters if an event reactivation counter is provided.</li>
 * </ul>
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption, OPTIONAL but strongly recommended, no specific length, must be null if not used
 * @param staticVectorInput Static vector, contains the DIGIPASS settings, MANDATORY, from 182 to 1916 hexadecimal characters (112 characters if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param serialNumber Serial number, 10 characters. MANDATORY. A serial number suffix can also be accepted (i.e. the 7 last characters of the serial number). In this case, the serial number prefix will be retrieved from the static vector
 * @param activationCode Activation code, used to activate the DIGIPASS, MANDATORY, from 20 to 41 decimal or hexadecimal characters according to the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:}, {@link DigipassPropertiesResponse#activationCodeFormatHexa} and {@link DigipassPropertiesResponse#useChecksumForActivationCode})
 * @param erc Event reactivation counter, contains the applications counters, OPTIONAL, only required for the reactivation of an event-based DIGIPASS, else must be null, from 3 to 91 decimal or hexadecimal characters according to the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#activationCodeFormatHexa})
 * @param activationPassword Activation password, used to decrypt the activation data, generated by the server, OPTIONAL, up to 512 characters, must be null if the activation data are not encrypted
 * @param password Password (as bytes) used to encrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordMandatory})
 * @param dynamicVector Dynamic vector, contains the DIGIPASS data, OPTIONAL, only required for a reactivation, else must be null, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectLength} if the static vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeSerialNumberNull} if the serial number is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeSerialNumberIncorrectLength} if the serial number length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeMultiDeviceActivationEnabled} if the multi-device activation is enabled in the DIGIPASS settings</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWeak} if the password is weak</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeNull} if the activation code is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeIncorrectLength} if the activation code length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeIncorrectFormat} if the activation code format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeInvalid} if the activation code is invalid</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeErcIncorrectLength} if the event reactivation counter length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeErcIncorrectFormat} if the event reactivation counter format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeErcInvalid} if the event reactivation counter is invalid</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeSharedSecretTooLong} if the size of the activation password is too high</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeReactivationLock} if the application has been locked in a reactivation case</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return A {@link DigipassSDKActivationResponse} object containing:
 * <ul>
 *  <li>The static vector ready to be stored, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the reactivation failed and if the reactivation fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#reactivationFatal})</li>
 * </ul>
 */
+ (DigipassSDKActivationResponse * _Nullable)activateOfflineWithFingerprint:(NSString * _Nullable)platformFingerprint
                                                               staticVector:(NSString *)staticVectorInput
                                                               serialNumber:(NSString *)serialNumber
                                                             activationCode:(NSString *)activationCode
                                                                        erc:(NSString * _Nullable)erc
                                                         activationPassword:(NSString * _Nullable)activationPassword
                                                                   password:(char * _Nullable)password
                                                              dynamicVector:(NSData * _Nullable)dynamicVector
                                                                      error:(NSError **)error;

/**
 * Online activation / reactivation process.
 * <ul>
 *  <li>Extracts the activation data from the XFAD.</li>
 *  <li>Parses the DIGIPASS settings.</li>
 *  <li>Checks, formats and decrypts the activation data.</li>
 *  <li>Extracts DIGIPASS secrets from the activation data and encrypts them by using a key derived from the password.</li>
 *  <li>Updates a DIGIPASS counters if an event reactivation counter is provided.</li>
 * </ul>
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption, OPTIONAL but strongly recommended, no specific length, must be null if not used
 * @param xfad Encrypted Full Activation Data, contains the activation data, MANDATORY, from 205 to 1738 hexadecimal characters (from 139 to 166 characters if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param xerc Encrypted Event Reactivation Counter, contains the applications counters, OPTIONAL, only required for the reactivation of an event-based DIGIPASS, else must be null, from 3 to 91 decimal or hexadecimal characters according to the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#activationCodeFormatHexa})
 * @param activationPassword Activation password, used to decrypt the activation data, generated by the server, OPTIONAL, must be null if the activation data are not encrypted.<br/>The cumulative size of the activationPassword and nonce parameters must not exceed 512 characters.
 * @param nonce Number used once, can be used for the activation data encryption: generated by the client (random or a time-dependent value), transmitted by to the server for the activation data encryption and provided to the DIGIPASS SDK for the decryption, OPTIONAL, can be used to avoid the generation of the same activation data successively.<br/>The cumulative size of the activationPassword and nonce parameters must not exceed 512 characters.
 * @param password Password (as bytes) used to encrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordMandatory})
 * @param dynamicVector Dynamic vector, contains the DIGIPASS data, OPTIONAL, only required for a reactivation, else must be null, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeXfadNull} if the XFAD is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeXfadIncorrectLength} if the XFAD length is invalid</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeXfadIncorrectFormat} if the XFAD format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeSharedSecretTooLong} if the cumulative size of the activation password and the nonce is too high</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeMultiDeviceActivationEnabled} if the multi-device activation is enabled in the DIGIPASS settings</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWeak} if the password is weak</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeIncorrectLength} if the activation code length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeIncorrectFormat} if the activation code format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeActivationCodeInvalid} if the activation code is invalid</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeXercIncorrectLength} if the event reactivation counter length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeXercIncorrectFormat} if the event reactivation counter format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeErcInvalid} if the event reactivation counter is invalid</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeReactivationLock} if the application has been locked in a reactivation case</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return A {@link DigipassSDKActivationResponse} object containing:
 * <ul>
 *  <li>The static vector ready to be stored, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the reactivation failed and if the reactivation fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#reactivationFatal})</li>
 * </ul>
 */
+ (DigipassSDKActivationResponse *_Nullable)activateOnlineWithFingerprint:(NSString * _Nullable)platformFingerprint
                                                                     xfad:(NSString *)xfad
                                                                     xerc:(NSString * _Nullable)xerc
                                                       activationPassword:(NSString * _Nullable)activationPassword
                                                                    nonce:(NSString * _Nullable)nonce
                                                                 password:(char * _Nullable)password
                                                            dynamicVector:(NSData * _Nullable)dynamicVector
                                                                    error:(NSError **)error;

/**
 * Response Only process.
 * <ul>
 *  <li>Validates the password.</li>
 *  <li>Generates an OTP.</li>
 *  <li>Updates the application data (status and counters) according to the validation and generation results.</li>
 * </ul>
 * @param staticVector Static vector, contains the DIGIPASS settings, MANDATORY, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param dynamicVector Dynamic vector, contains DIGIPASS data, MANDATORY, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param password Password (as bytes) used to decrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordProtected})
 * @param clientServerTimeShift Client/Server time shift in seconds, OPTIONAL, recommended if the application to use is time-based, else must be 0, use {@link DigipassSDK#computeClientServerTimeShiftFromServerTime:} to compute this value
 * @param cryptoApplicationIndex Crypto application index, indicates which application must be used to generate the response, MANDATORY, from {@link DigipassSDKConstants#cryptoApplicationIndexApp1} to {@link DigipassSDKConstants#cryptoApplicationIndexApp8}
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption and for the token derivation if supported.
 *        <br/>With standard activation, the platform fingerprint is OPTIONAL but strongly recommended, no specific length, must be null if not used. The platform fingerprint is used to perform the token derivation only if the {@link DigipassSDK#generateDerivationCodeWithStaticVector:dynamicVector:password:clientServerTimeShift:cryptoApplicationIndex:platformFingerprint:challenge:error:} has already been called. For a DIGIPASS created by a DIGIPASS SDK 4.0 (<=> {@link DigipassPropertiesResponse#creationVersion} < 3), the platform fingerprint is used to perform the token derivation even if if the {@link DigipassSDK#generateDerivationCodeWithStaticVector:dynamicVector:password:clientServerTimeShift:cryptoApplicationIndex:platformFingerprint:challenge:error:} has not been called.
 *        <br/>With multi-device activation, the platform fingerprint is MANDATORY.
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectLength} if the static vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorNull} if the dynamic vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStatusInvalid} if the status is invalid (not activated or locked), an activation is required</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordLock} if the application is locked after too many wrong tries</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWrong} if the password is cannot be validated</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeNotPasswordProtected} if the DIGIPASS is not password protected</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeCryptoApplicationIndexInvalid} if the crypto application index is invalid, use {@link DigipassSDKConstants#cryptoApplicationIndexApp1} ... {@link DigipassSDKConstants#cryptoApplicationIndexApp8}</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeApplicationDisabled} if the crypto application is disabled in the DIGIPASS settings</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePlatformFingerprintNotDefined} if the platform fingerprint is not defined</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return A {@link DigipassSDKGenerationResponse} object containing:
 * <ul>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the password validation failed and if the password fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordFatal})</li>
 *  <li>The generated response (OTP)</li>
 *  <li>The generated host code, if the host code is enabled for the crypto application (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassSDKApplication#hostCodeLength})</li>
 * </ul>
 */
+ (DigipassSDKGenerationResponse * _Nullable)generateResponseOnlyWithStaticVector:(NSData *)staticVector
                                                                    dynamicVector:(NSData *)dynamicVector
                                                                         password:(char * _Nullable)password
                                                            clientServerTimeShift:(NSInteger)clientServerTimeShift
                                                           cryptoApplicationIndex:(NSInteger)cryptoApplicationIndex
                                                              platformFingerprint:(NSString * _Nullable)platformFingerprint
                                                                            error:(NSError **)error;

/**
 * Challenge Response process.
 * <ul>
 *  <li>Validates the password.</li>
 *  <li>Generates a response by signing the challenge.</li>
 *  <li>Updates the application data (status and counters) according to the validation and generation results.</li>
 * </ul>
 * @param staticVector Static vector, contains the DIGIPASS settings, MANDATORY, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param dynamicVector Dynamic vector, contains DIGIPASS data, MANDATORY, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param challenge Challenge to sign, up to 16 valid characters, MANDATORY can be empty but not null, length defined in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:}, {@link DigipassSDKApplication#dataFieldsMinLength} and {@link DigipassSDKApplication#dataFieldsMaxLength})
 * @param password Password (as bytes) used to decrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordProtected})
 * @param clientServerTimeShift Client/Server time shift in seconds, OPTIONAL, recommended if the application to use is time-based, else must be 0, use {@link DigipassSDK#computeClientServerTimeShiftFromServerTime:} to compute this value
 * @param cryptoApplicationIndex Crypto application index, indicates which application must be used to generate the response, MANDATORY, from {@link DigipassSDKConstants#cryptoApplicationIndexApp1} to {@link DigipassSDKConstants#cryptoApplicationIndexApp8}
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption and for the token derivation if supported.
 *        <br/>With standard activation, the platform fingerprint is OPTIONAL but strongly recommended, no specific length, must be null if not used. The platform fingerprint is used to perform the token derivation only if the {@link DigipassSDK#generateDerivationCodeWithStaticVector:dynamicVector:password:clientServerTimeShift:cryptoApplicationIndex:platformFingerprint:challenge:error:} has already been called. For a DIGIPASS created by a DIGIPASS SDK 4.0 (<=> {@link DigipassPropertiesResponse#creationVersion} < 3), the platform fingerprint is used to perform the token derivation even if if the {@link DigipassSDK#generateDerivationCodeWithStaticVector:dynamicVector:password:clientServerTimeShift:cryptoApplicationIndex:platformFingerprint:challenge:error:} has not been called.
 *        <br/>With multi-device activation, the platform fingerprint is MANDATORY.
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectLength} if the static vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorNull} if the dynamic vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStatusInvalid} if the status is invalid (not activated or locked), an activation is required</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordLock} if the application is locked after too many wrong tries</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWrong} if the password is cannot be validated</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeNotPasswordProtected} if the DIGIPASS is not password protected</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeCryptoApplicationIndexInvalid} if the crypto application index is invalid, use {@link DigipassSDKConstants#cryptoApplicationIndexApp1} ... {@link DigipassSDKConstants#cryptoApplicationIndexApp8}</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeApplicationDisabled} if the crypto application is disabled in the DIGIPASS settings</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeChallengeNull} if the challenge is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeChallengeIncorrectLength} if the challenge length is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeChallengeCharacterInvalid} if one of the data to sign contains invalid characters</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePlatformFingerprintNotDefined} if the platform fingerprint is not defined</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return A {@link DigipassSDKGenerationResponse} object containing:
 * <ul>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the password validation failed and if the password fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordFatal})</li>
 *  <li>The generated response (OTP)</li>
 *  <li>The generated host code, if the host code is enabled for the crypto application (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassSDKApplication#hostCodeLength})</li>
 * </ul>
 */
+ (DigipassSDKGenerationResponse * _Nullable)generateResponseFromChallenge:(NSString *)challenge
                                                              staticVector:(NSData *)staticVector
                                                             dynamicVector:(NSData *)dynamicVector
                                                                  password:(char * _Nullable)password
                                                     clientServerTimeShift:(NSInteger)clientServerTimeShift
                                                    cryptoApplicationIndex:(NSInteger)cryptoApplicationIndex
                                                       platformFingerprint:(NSString * _Nullable)platformFingerprint
                                                                     error:(NSError **)error;

/**
 * Signature process.
 * <ul>
 *  <li>Validates the password.</li>
 *  <li>Generates a signature by signing the data fields.</li>
 *  <li>Updates the application data (status and counters) according to the validation and generation results.</li>
 * </ul>
 * @param staticVector Static vector, contains the DIGIPASS settings, MANDATORY, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param dynamicVector Dynamic vector, contains DIGIPASS data, MANDATORY, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param dataFields Data fields to sign, up to 8 strings having up to 16 valid characters, the array length must not exceed the data fields number contained in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:}, {@link DigipassSDKApplication#dataFieldNumber}, {@link DigipassSDKApplication#dataFieldsMinLength} and {@link DigipassSDKApplication#dataFieldsMaxLength})
 * @param password Password (as bytes) used to decrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordProtected})
 * @param clientServerTimeShift Client/Server time shift in seconds, OPTIONAL, recommended if the application to use is time-based, else must be 0, use {@link DigipassSDK#computeClientServerTimeShiftFromServerTime:} to compute this value
 * @param cryptoApplicationIndex Crypto application index, indicates which application must be used to generate the response, MANDATORY, from {@link DigipassSDKConstants#cryptoApplicationIndexApp1} to {@link DigipassSDKConstants#cryptoApplicationIndexApp8}
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption and for the token derivation if supported.
 *        <br/>With standard activation, the platform fingerprint is OPTIONAL but strongly recommended, no specific length, must be null if not used. The platform fingerprint is used to perform the token derivation only if the {@link DigipassSDK#generateDerivationCodeWithStaticVector:dynamicVector:password:clientServerTimeShift:cryptoApplicationIndex:platformFingerprint:challenge:error:} has already been called. For a DIGIPASS created by a DIGIPASS SDK 4.0 (<=> {@link DigipassPropertiesResponse#creationVersion} < 3), the platform fingerprint is used to perform the token derivation even if if the {@link DigipassSDK#generateDerivationCodeWithStaticVector:dynamicVector:password:clientServerTimeShift:cryptoApplicationIndex:platformFingerprint:challenge:error:} has not been called.
 *        <br/>With multi-device activation, the platform fingerprint is MANDATORY.
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectLength} if the static vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorNull} if the dynamic vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStatusInvalid} if the status is invalid (not activated or locked), an activation is required</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordLock} if the application is locked after too many wrong tries</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWrong} if the password is cannot be validated</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeNotPasswordProtected} if the DIGIPASS is not password protected</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeCryptoApplicationIndexInvalid} if the crypto application index is invalid, use {@link DigipassSDKConstants#cryptoApplicationIndexApp1} ... {@link DigipassSDKConstants#cryptoApplicationIndexApp8}</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeApplicationDisabled} if the crypto application is disabled in the DIGIPASS settings</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDataFieldsArrayNull} if the data fields array is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDataFieldsNumberInvalid} if the number of data fields to sign is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDataFieldNull} if one of the data fields to sign is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDataFieldIncorrectLength} if one of the data fields to sign length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDataFieldsNotContiguous} if one of the data fields is empty between two not empty data fields</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeChallengeCharacterInvalid} if one of the data to sign contains invalid characters</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePlatformFingerprintNotDefined} if the platform fingerprint is not defined</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return A {@link DigipassSDKSignatureResponse} object containing:
 * <ul>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the password validation failed and if the password fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordFatal})</li>
 *  <li>The generated response (signature)</li>
 *  <li>The generated host code, if the host code is enabled for the crypto application (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassSDKApplication#hostCodeLength})</li>
 * </ul>
 */
+ (DigipassSDKSignatureResponse *_Nullable)generateSignatureWithStaticVector:(NSData *)staticVector
                                                               dynamicVector:(NSData *)dynamicVector
                                                                  dataFields:(NSArray<NSString *>*)dataFields
                                                                    password:(char * _Nullable)password
                                                       clientServerTimeShift:(NSInteger)clientServerTimeShift
                                                      cryptoApplicationIndex:(NSInteger)cryptoApplicationIndex
                                                         platformFingerprint:(NSString * _Nullable)platformFingerprint
                                                                       error:(NSError **)error;

/**
 * Checks the password weakness.
 * @param password Password (as bytes) to check
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return True in the following cases
 * <ul>
 *  <li>The password is null or empty.</li>
 *  <li>The password contains less than four characters.</li>
 *  <li>The difference between each consecutive characters is constant.</li>
 *  <li>The password contains a row of 0s (N-1 0s for a PIN of N digits) followed by a number (e.g. 00003) or a number followed by a row of 0s (e.g. 2000).</li>
 * </ul>
 */
+ (BOOL)isPasswordWeak:(char * _Nullable)password;

/**
 * Password validation process.
 * <ul>
 *  <li>Validates the password.</li>
 *  <li>Updates the application data (status and counters) according to the validation result.</li>
 *  <li>Generates an encryption key which can be used in the xxxWithKey methods in order to avoid the use of the password.</li>
 * </ul>
 * @param staticVector Static vector, contains the DIGIPASS settings, MANDATORY, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param dynamicVector Dynamic vector, contains DIGIPASS data, MANDATORY, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param password Password (as bytes) used to decrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordProtected})
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption, OPTIONAL but strongly recommended, no specific length, must be null if not used
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectLength} if the static vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorNull} if the dynamic vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordLock} if the application is locked after too many wrong tries</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWrong} if the password is cannot be validated</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeNotPasswordProtected} if the DIGIPASS is not password protected</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *
 * @return A {@link DigipassSDKGenericResponse} object containing:
 * <ul>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the password validation failed and if the password fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordFatal})</li>
 *  <li>The encryption key required to decrypt DIGIPASS secret, 16 bytes, null if the validation failed</li>
 * </ul>
 */
+ (DigipassSDKGenericResponse * _Nullable)validatePasswordWithFingerprint:(NSString * _Nullable)platformFingerprint
                                                             staticVector:(NSData *)staticVector
                                                            dynamicVector:(NSData *)dynamicVector
                                                            encryptionKey:(NSData *)encryptionKey
                                                                 password:(char * _Nullable)password
                                                                    error:(NSError **)error;

/**
 * Password change process.
 * <ul>
 *  <li>Validates the old password.</li>
 *  <li>Migrates the application sensitive data by using the passwords.</li>
 * </ul>
 * @param platformFingerprint Platform fingerprint used for the DIGIPASS secrets encryption, OPTIONAL but strongly recommended, no specific length, must be null if not used
 * @param staticVector Static vector, contains the DIGIPASS settings, MANDATORY, from 91 to 958 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param dynamicVector Dynamic vector, contains DIGIPASS data, OPTIONAL, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})
 * @param oldPassword Old password (as bytes) used to decrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordProtected})
 * @param newPassword New password (as bytes) used to encrypt DIGIPASS secrets, MANDATORY if the password is required in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordProtected})
 * @param error raised if there is an error during the process. The following codes can be returned:
 * <ul>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectLength} if the static vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorNull} if the dynamic vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeDynamicVectorIncorrectLength} if the dynamic vector length is incorrect </li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorIncorrectFormat} if the static vector format is incorrect</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeStaticVectorNull} if the static vector is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordNull} if the password is null</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordLock} if the application is locked after too many wrong tries</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWrong} if the password is cannot be validated</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodePasswordWeak} if the new password is weak or equal to the old password</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeNotPasswordProtected} if the DIGIPASS is not password protected</li>
 *  <li>{@link DigipassSDKErrorCodes#returnCodeUnknownError} if an unknown has occurred</li>
 * </ul>
 * \warning Passwords are used as char* to prevent unecessary copies of the password in memory.
 *  We **strongly** encourage you to reset your byte buffer as soon as possible using the following example
 *   @code
 *    char password[] = "password";
 *    // ...
 *    memset(password, 0, strlen(password));
 *   @endcode
 *   
 * @return A {@link DigipassSDKGenericResponse} object containing:
 * <ul>
 *  <li>The dynamic vector ready to be stored, from 80 to 303 bytes (56 if static vector version < 8, see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#version})</li>
 *  <li>The attempt left if the old password validation failed and if the password fatal counter is enabled in the DIGIPASS settings (see {@link DigipassSDK#digipassPropertiesWithStaticVector:dynamicVector:error:} and {@link DigipassPropertiesResponse#passwordFatal})</li>
 * </ul>
 */
+ (DigipassSDKGenericResponse * _Nullable)changePasswordWithFingerprint:(NSString * _Nullable)platformFingerprint
                                                           staticVector:(NSData *)staticVector
                                                          dynamicVector:(NSData *)dynamicVector
                                                            oldPassword:(char * _Nullable)oldPassword
                                                            newPassword:(char * _Nullable)newPassword
                                                                  error:(NSError **)error;

@end

NS_ASSUME_NONNULL_END
